<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title id="head-title">report_lidar.html</title>
      <link href="assets\style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <h1 id="title">report_lidar.html</h1>
    <p>Report generated on 16-Feb-2026 at 13:11:56 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a>
        v4.2.0</p>
    <div id="environment-header">
      <h2>Environment</h2>
    </div>
    <table id="environment"></table>
    <!-- TEMPLATES -->
      <template id="template_environment_row">
      <tr>
        <td></td>
        <td></td>
      </tr>
    </template>
    <template id="template_results-table__body--empty">
      <tbody class="results-table-row">
        <tr id="not-found-message">
          <td colspan="6">No results found. Check the filters.</td>
        </tr>
      </tbody>
    </template>
    <template id="template_results-table__tbody">
      <tbody class="results-table-row">
        <tr class="collapsible">
        </tr>
        <tr class="extras-row">
          <td class="extra" colspan="6">
            <div class="extraHTML"></div>
            <div class="media">
              <div class="media-container">
                  <div class="media-container__nav--left">&lt;</div>
                  <div class="media-container__viewport">
                    <img src="" />
                    <video controls>
                      <source src="" type="video/mp4">
                    </video>
                  </div>
                  <div class="media-container__nav--right">&gt;</div>
                </div>
                <div class="media__name"></div>
                <div class="media__counter"></div>
            </div>
            <div class="logwrapper">
              <div class="logexpander"></div>
              <div class="log"></div>
            </div>
          </td>
        </tr>
      </tbody>
    </template>
    <!-- END TEMPLATES -->
    <div class="summary">
      <div class="summary__data">
        <h2>Summary</h2>
        <div class="additional-summary prefix">
        </div>
        <p class="run-count">26 tests took 00:00:32.</p>
        <p class="filter">(Un)check the boxes to filter the results.</p>
        <div class="summary__reload">
          <div class="summary__reload__button hidden" onclick="location.reload()">
            <div>There are still tests running. <br />Reload this page to get the latest results!</div>
          </div>
        </div>
        <div class="summary__spacer"></div>
        <div class="controls">
          <div class="filters">
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="failed" disabled>
            <span class="failed">0 Failed,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="passed" >
            <span class="passed">26 Passed,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="skipped" disabled>
            <span class="skipped">0 Skipped,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="xfailed" disabled>
            <span class="xfailed">0 Expected failures,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="xpassed" disabled>
            <span class="xpassed">0 Unexpected passes,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="error" disabled>
            <span class="error">0 Errors,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="rerun" disabled>
            <span class="rerun">0 Reruns</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="retried" disabled>
            <span class="retried">0 Retried,</span>
          </div>
          <div class="collapse">
            <button id="show_all_details">Show all details</button>&nbsp;/&nbsp;<button id="hide_all_details">Hide all details</button>
          </div>
        </div>
      </div>
      <div class="additional-summary summary">
      </div>
      <div class="additional-summary postfix">
      </div>
    </div>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable" data-column-type="result">Result</th>
          <th class="sortable" data-column-type="testId">Test</th>
          <th class="sortable" data-column-type="duration">Duration</th>
          <th class="col-testmeta">Test Description</th>
          <th class="col-plot">Plot</th>
          <th>Links</th>
        </tr>
      </thead>
    </table>
  <footer>
    <div id="data-container" data-jsonblob="{&#34;environment&#34;: {&#34;Python&#34;: &#34;3.14.0&#34;, &#34;Platform&#34;: &#34;Windows-11-10.0.26200-SP0&#34;, &#34;Packages&#34;: {&#34;pytest&#34;: &#34;9.0.2&#34;, &#34;pluggy&#34;: &#34;1.6.0&#34;}, &#34;Plugins&#34;: {&#34;html&#34;: &#34;4.2.0&#34;, &#34;metadata&#34;: &#34;3.1.1&#34;}}, &#34;tests&#34;: {&#34;tests/test_lidar.py::test_range_accuracy_zero_noise_boresight&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;range_accuracy_zero_noise&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_range_accuracy_zero_noise_boresight_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_range_accuracy_zero_noise_boresight&#34;, &#34;duration&#34;: &#34;663 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_range_accuracy_zero_noise_boresight&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;663 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Verify zero noise boresight ranging over the full measurement envelope.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the deterministic measurement pipeline reproduces ground truth range with no stochastic terms.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Measured range equals true range at machine precision for every sampled distance from 0 to max range.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_range_accuracy_zero_noise_boresight_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_range_accuracy_zero_noise_boresight_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_fov_boundary_transition&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;fov_boundary_transition&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_fov_boundary_transition_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_fov_boundary_transition&#34;, &#34;duration&#34;: &#34;309 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_fov_boundary_transition&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;309 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Sweep target angle from outside negative FoV to outside positive FoV and evaluate boundary behavior.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Identify where measurement validity transitions between valid and out_of_fov relative to half FoV limits.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Sweep starts invalid, center is valid, sweep ends invalid, and epsilon checks at both boundaries match expected valid/invalid transitions.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_fov_boundary_transition_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_fov_boundary_transition_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_range_boundary_transition&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;range_boundary_transition&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_range_boundary_transition_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_range_boundary_transition&#34;, &#34;duration&#34;: &#34;360 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_range_boundary_transition&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;360 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Sweep target range from below minimum range to above maximum range and evaluate boundary behavior.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Identify where measurement validity transitions between valid and out_of_range at range_min and range_max.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Near range_min, minus epsilon is invalid while boundary and plus epsilon are valid; near range_max, minus epsilon and boundary are valid while plus epsilon is invalid; sweep starts invalid, is valid inside limits, and ends invalid.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_range_boundary_transition_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_range_boundary_transition_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_beam_pattern_geometry_planar_wall&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;beam_pattern_geometry_planar_wall&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_beam_pattern_geometry_planar_wall_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_beam_pattern_geometry_planar_wall&#34;, &#34;duration&#34;: &#34;536 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_beam_pattern_geometry_planar_wall&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;536 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Fire a single elevation scan pattern at a planar wall perpendicular to boresight and validate beam geometry.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm hit geometry follows the expected wall intersection model, azimuth indices are ordered correctly, and azimuth spacing matches the configured linspace pattern.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; All beams return valid hits on the wall, hit points match analytic intersections, azimuth_index equals 0..N-1, and azimuth samples and spacing match linspace(az_min, az_max, N).&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_beam_pattern_geometry_planar_wall_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_beam_pattern_geometry_planar_wall_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_gaussian_range_noise&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;gaussian_range_noise&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_gaussian_range_noise_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_gaussian_range_noise&#34;, &#34;duration&#34;: &#34;00:00:02&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_gaussian_range_noise&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:02&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Monte Carlo validation of Gaussian range noise statistics against configured parameters. Collect N=10000 samples at fixed ranges, verify empirical standard deviation matches the RSS noise formula within a chi-squared confidence interval, and confirm near-zero mean error.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the stochastic range noise pipeline reproduces the expected distribution: zero-mean Gaussian with sigma_total(r) = sqrt(range_accuracy^2 + (noise_range_coeff * r)^2).&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; At every test range the sample variance ratio s^2/sigma^2 lies within the 99 percent chi-squared confidence interval and the sample mean error is within 3*sigma/sqrt(N) of zero.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_gaussian_range_noise_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_gaussian_range_noise_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_bias_random_walk&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;bias_random_walk&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_bias_random_walk_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_bias_random_walk&#34;, &#34;duration&#34;: &#34;00:00:03&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_bias_random_walk&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:03&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Ensemble Monte Carlo validation of the bias random walk process. Run N_ensemble=500 independent sensors over a long time series and verify the ensemble variance of bias(t) grows linearly as bias_rw_std^2 * t.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the bias state performs a Wiener process: Var[bias(T) - bias(0)] = sigma_rw^2 * T at several time horizons.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; At every sampled time horizon the ensemble variance ratio Var/expected lies within the 99 percent chi-squared confidence interval. Sample trajectories visually exhibit random walk behavior.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_bias_random_walk_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_bias_random_walk_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_bias_drift&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;bias_drift&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_bias_drift_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_bias_drift&#34;, &#34;duration&#34;: &#34;182 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_bias_drift&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;182 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Verify that enabling only bias_drift_rate produces a linearly growing range error whose slope matches the configured drift rate exactly.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the deterministic bias drift component: error(t) = bias_drift_rate * t with no stochastic scatter.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Measured range error at every time step equals bias_drift_rate * t within machine precision.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_bias_drift_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_bias_drift_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_scale_factor&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;scale_factor&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_scale_factor_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_scale_factor&#34;, &#34;duration&#34;: &#34;00:00:02&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_scale_factor&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:02&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Validate both deterministic and stochastic scale factor models. With a fixed scale_factor_ppm, verify measured = true * (1 + sf) at several ranges. With scale_error_std_ppm, instantiate N=10000 sensors and verify the distribution of realised scale factors matches the configured Gaussian.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the deterministic scale factor applies a precise multiplicative offset, and the stochastic per-sensor scale error is drawn from the correct N(0, sigma_ppm) distribution.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Deterministic case: measured equals true*(1+sf) within machine precision at every test range. Stochastic case: empirical mean and variance of realised scale factors lie within 99 percent confidence intervals.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_scale_factor_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_scale_factor_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_outlier_injection&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;outlier_injection&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_outlier_injection_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_outlier_injection&#34;, &#34;duration&#34;: &#34;00:00:01&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_outlier_injection&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:01&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Monte Carlo validation of outlier injection rate and magnitude distribution. With outlier_prob=0.10, collect N=10000 samples and verify the empirical outlier rate matches the configured probability. Confirm outlier magnitudes follow N(outlier_bias, outlier_std^2).&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the outlier injection mechanism fires at the correct rate and draws gross errors from the expected Gaussian distribution.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Empirical outlier rate lies within a 99 percent binomial confidence interval of outlier_prob. Outlier magnitude mean and standard deviation match outlier_bias and outlier_std within chi-squared and normal confidence bounds.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_outlier_injection_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_outlier_injection_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_dropout_rate&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;dropout_rate&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_dropout_rate_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_dropout_rate&#34;, &#34;duration&#34;: &#34;00:00:06&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_dropout_rate&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:06&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Monte Carlo validation of dropout probability vs range. Sweep multiple ranges, collect N=10000 samples per range using the asynchronous pipeline, and verify the empirical dropout fraction matches the linear model p_drop(r) = dropout_prob + dropout_range_coeff * normalised_range.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm dropout rate at close range is near the baseline, at max range is baseline + dropout_range_coeff, and the relationship is linear in normalised range.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; At every test range the configured dropout probability lies within the 99 percent binomial confidence interval of the observed dropout fraction. A linear fit through the empirical dropout fractions has slope consistent with dropout_range_coeff.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_dropout_rate_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_dropout_rate_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_quantization_step&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;quantization_step&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_quantization_step_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_quantization_step&#34;, &#34;duration&#34;: &#34;932 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_quantization_step&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;932 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Sweep true range with fine resolution through a nonzero quantization step and verify every output snaps to the nearest multiple. Confirm the quantization residual forms a sawtooth bounded by \u00b1step/2.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Validate that the output quantization stage rounds each measurement to the nearest integer multiple of quantization_step, producing the expected staircase transfer function and bounded sawtooth residual.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Every measured range is an exact integer multiple of quantization_step. The residual (measured \u2212 true) is bounded within \u00b1step/2 at every sample point.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_quantization_step_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_quantization_step_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_saturation_vs_invalidation&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;saturation_vs_invalidation&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_saturation_vs_invalidation_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_saturation_vs_invalidation&#34;, &#34;duration&#34;: &#34;965 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_saturation_vs_invalidation&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;965 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Compare saturation clipping vs invalidation behaviour when the measured range is pushed beyond range_max (via large positive bias) and below range_min (via large negative bias). With saturate_output=True the output must clip; with saturate_output=False it must return an invalid measurement with reason=&amp;#x27;saturated&amp;#x27;.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the two output limit modes work correctly: hard clipping to [range_min, range_max] versus outright measurement rejection when the noisy range falls outside the envelope.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Clipping mode: output equals range_max when bias pushes high, range_min when bias pushes low. Invalidation mode: measurement is invalid with reason=&amp;#x27;saturated&amp;#x27; for both high and low cases. Nominal range (no bias push) remains valid and accurate in both modes.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_saturation_vs_invalidation_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_saturation_vs_invalidation_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_sampling_rate&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;sampling_rate&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_sampling_rate_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_sampling_rate&#34;, &#34;duration&#34;: &#34;677 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_sampling_rate&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;677 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Feed measure() with current_time advancing at 1 ms resolution and verify that new measurements appear at exactly 1/sampling_rate intervals. Count the total number of non-stale measurements over a known duration and confirm the count matches the expected number of sampling periods.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Validate the internal sample clock: the sensor must produce one new measurement per sampling period regardless of how finely the caller ticks the simulation clock.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Total new measurement count equals floor(duration * sampling_rate) + 1 (initial sample). Every inter-measurement interval equals 1/sampling_rate within numerical tolerance.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_sampling_rate_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_sampling_rate_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_latency&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;latency_pipeline&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_latency_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_latency&#34;, &#34;duration&#34;: &#34;413 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_latency&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;413 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Verify that a measurement triggered at sample epoch t does not appear in the output until current_time &amp;gt;= t + latency. Before that threshold the sensor must return a stale placeholder. After the latency elapses the measurement must carry the correct sample timestamp equal to the original sample epoch.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the latency pipeline delays measurement delivery by exactly the configured latency value and that the returned timestamp reflects the sample epoch, not the delivery time.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; All calls with current_time &amp;lt; first_sample_epoch + latency return stale. The first non-stale call occurs at current_time &amp;gt;= first_sample_epoch + latency and carries timestamp == first_sample_epoch. Multiple latency values are swept to confirm the relationship holds across the range.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_latency_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_latency_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_time_jitter&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;time_jitter&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_time_jitter_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_time_jitter&#34;, &#34;duration&#34;: &#34;00:00:02&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_time_jitter&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:02&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Validate both timing jitter injection paths independently. Part A: enable only sample_time_jitter_std, call measure() at mid-period cadence so the sample epoch sits in the centre of the caller interval (avoiding internal clamp truncation), and verify the sample epoch jitter std via chi-squared 99 %% CI. Part B: enable only latency_jitter_std, tick at fine resolution (0.5 ms), and verify the delivery delay jitter std via chi-squared 99 %% CI.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm sample epoch jitter and latency jitter each produce the configured statistical spread in their respective output domains when tested in isolation.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Part A: sample epoch jitter std lies within 99 %% chi-squared CI around sample_time_jitter_std. Part B: delivery delay jitter std lies within 99 %% chi-squared CI around sqrt(latency_jitter_std^2 + (dt_fine^2)/12).&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_time_jitter_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_time_jitter_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_time_reversal_handling&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;time_reversal_handling&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_time_reversal_handling_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_time_reversal_handling&#34;, &#34;duration&#34;: &#34;499 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_time_reversal_handling&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;499 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Feed the sensor with a normally advancing time sequence, then inject a backward timestamp (time reversal). Verify the pipeline resets gracefully: no exception, pending measurements are cleared, and the sensor resumes correct operation from the new (earlier) time reference. A non-zero latency is used so the pending queue accumulates entries before the reversal, making the flush observable.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the time reversal detection logic clears stale pipeline state and allows the sensor to recover without crashing or producing corrupt output.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; No exceptions raised during or after the reversal. The pending queue drops from a non-zero count to at most 1 entry. Subsequent ticks resume normal operation with monotonically increasing timestamps rooted at the reversal point.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_time_reversal_handling_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_time_reversal_handling_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_position_interpolation&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;position_interpolation&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_position_interpolation_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_position_interpolation&#34;, &#34;duration&#34;: &#34;482 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_position_interpolation&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;482 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Move a target linearly from position A to position B over one sampling period. A deliberately coarse caller tick (0.3 s) is used with a 2 Hz sensor so the sample epoch falls mid-interval rather than on a call boundary, exercising the internal linear interpolation. For each velocity profile the measured range is compared against the true position at the sample epoch and against the naive call-time position to demonstrate the interpolation benefit.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Validate the intra-period position interpolation logic that aligns each range sample with the target&amp;#x27;s true position at the sample epoch rather than at the caller&amp;#x27;s clock.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; For each velocity profile the measured range equals the Euclidean distance to the linearly interpolated position at the sample epoch within 1e-6 m precision. The naive call-time range error is visibly larger for non-zero velocities.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_position_interpolation_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_position_interpolation_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_received_power_vs_range&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;received_power_vs_range&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_received_power_vs_range_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_received_power_vs_range&#34;, &#34;duration&#34;: &#34;00:00:01&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_received_power_vs_range&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:01&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Sweep target range with atmosphere disabled, Lambertian reflectivity, and normal incidence. Received power should follow a 1/r^4 law (1/r^2 geometric falloff divided by footprint area proportional to r^2). A linear fit on the log-log plot must recover slope = -4 within tight tolerance.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Validate the geometric and footprint area terms of the lidar link budget equation in isolation from atmospheric and angular effects.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; log-log slope of received power vs range equals -4.0 within +-0.01. Absolute power at every range matches the closed-form prediction within 1e-12 relative error.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_received_power_vs_range_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_received_power_vs_range_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_atmosphere_extinction&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;atmosphere_extinction&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_atmosphere_extinction_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_atmosphere_extinction&#34;, &#34;duration&#34;: &#34;450 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_atmosphere_extinction&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;450 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Enable atmosphere_extinction_coeff while keeping all other factors fixed. Sweep range and verify received power decays as exp(-2 alpha r) on top of the geometric 1/r^4 baseline. Recover the extinction coefficient from the data and compare to the configured value.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Validate the Beer-Lambert two-way atmospheric attenuation term in isolation.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Recovered extinction coefficient matches the configured value within 1%%. Attenuation ratio P_atm / P_no_atm equals exp(-2 alpha r) within 1e-12 at every range.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_atmosphere_extinction_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_atmosphere_extinction_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_incidence_angle_dependence&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;incidence_angle_dependence&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_incidence_angle_dependence_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_incidence_angle_dependence&#34;, &#34;duration&#34;: &#34;421 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_incidence_angle_dependence&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;421 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Fix range and atmosphere, sweep the surface incidence angle from near-normal to near-grazing. With retro_reflectivity = 0 the Lambertian model predicts received power proportional to cos(incidence angle). Verify proportionality and plot the angular dependence.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Validate the diffuse (Lambertian) reflectance term: power scales linearly with cos(theta) when retro-reflectivity is zero.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Normalized power P(theta)/P(0) equals cos(theta) within 1e-12 at every tested angle.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_incidence_angle_dependence_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_incidence_angle_dependence_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_retro_reflectivity&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;retro_reflectivity&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_retro_reflectivity_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_retro_reflectivity&#34;, &#34;duration&#34;: &#34;548 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_retro_reflectivity&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;548 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Set retro_reflectivity &amp;gt; 0 on a material and sweep the incidence angle. The retro component adds a constant power offset independent of theta, so P_retro(theta) - P_base(theta) should be constant across all angles.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the retro-reflective term contributes a fixed, angle-independent boost to received power as specified by the link budget equation.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; The absolute power difference (P_retro - P_base) is constant across all incidence angles within 1e-12 relative tolerance. The expected boost equals the power that would result from replacing rho_d*cos(theta) with rho_r in the link budget.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_retro_reflectivity_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_retro_reflectivity_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_snr_detection_threshold&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;snr_detection_threshold&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_snr_detection_threshold_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_snr_detection_threshold&#34;, &#34;duration&#34;: &#34;00:00:05&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_snr_detection_threshold&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;00:00:05&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Analytically compute the range at which detection_probability = 50 %% from the link budget equation (P_rx = P_min at r_50). Then run a Monte Carlo sweep over range using a single-beam scanner aimed at a perpendicular plane and verify the empirical detection rate crosses 50 %% at the predicted range.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; End-to-end validation of the SNR-based detection model: the sigmoid detection probability P_rx / (P_rx + P_min) must produce the expected detection statistics as a function of range.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Empirical 50 %% crossing range (linear interpolation) lies within 5 %% of the analytically predicted r_50. At close range (r &amp;lt;&amp;lt; r_50) detection rate is near 100 %%; at far range (r &amp;gt;&amp;gt; r_50) it drops toward 0 %%.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_snr_detection_threshold_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_snr_detection_threshold_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_full_frame_sphere_consistency&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;full_frame_sphere_consistency&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_full_frame_sphere_consistency_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_full_frame_sphere_consistency&#34;, &#34;duration&#34;: &#34;538 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_full_frame_sphere_consistency&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;538 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Scan a sphere centered on boresight. Valid returns should form a circular cluster in azimuth/elevation space bounded by the angular subtent of the sphere. Reconstruct a point cloud from the hit points and verify every point lies on the sphere surface within machine precision.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; End-to-end validation of the full-frame scan pipeline: beam generation, ray casting against a sphere, and geometric consistency of the returned point cloud.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; All hit points satisfy |hit - center| = radius within 1e-6 m. The angular extent of valid returns matches the geometric subtent of the sphere. No valid return lies outside the sphere&amp;#x27;s angular footprint.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_full_frame_sphere_consistency_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_full_frame_sphere_consistency_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_multi_object_occlusion&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;multi_object_occlusion&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_multi_object_occlusion_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_multi_object_occlusion&#34;, &#34;duration&#34;: &#34;492 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_multi_object_occlusion&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;492 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Place a small sphere in front of a large wall along the sensor boresight. Beams that intersect the sphere must report the sphere&amp;#x27;s range, not the wall&amp;#x27;s. Beams that miss the sphere should hit the wall at the expected range.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Verify the scene ray caster returns the closest intersection when multiple objects lie along the same ray direction.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; Every beam that hits the sphere reports object_id = sphere and range consistent with the sphere geometry. Every beam that misses the sphere reports object_id = wall and range consistent with the wall geometry. No beam detects the far wall through the sphere.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_multi_object_occlusion_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_multi_object_occlusion_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_rotated_sensor&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;rotated_sensor&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_rotated_sensor_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_rotated_sensor&#34;, &#34;duration&#34;: &#34;493 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_rotated_sensor&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;493 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Apply a known yaw rotation to sensor_orientation and scan a target on the world +x axis. With zero rotation the target sits at azimuth = 0. With a yaw of +theta the sensor&amp;#x27;s boresight rotates, so the target should appear at azimuth = -theta in the scan pattern. Verify the peak return shifts by the expected number of azimuth indices.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the sensor_orientation rotation matrix correctly transforms beam directions from the sensor body frame to the world frame.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; The azimuth index of the closest return to the target shifts by exactly the number of indices corresponding to the applied yaw angle. The measured range is consistent with the rotated geometry.&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_rotated_sensor_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_rotated_sensor_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_lidar.py::test_empty_scene&#34;: [{&#34;extras&#34;: [{&#34;name&#34;: &#34;empty_scene&#34;, &#34;format_type&#34;: &#34;image&#34;, &#34;content&#34;: &#34;assets\\tests_test_lidar.py__test_empty_scene_0_0.png&#34;, &#34;mime_type&#34;: &#34;image/png&#34;, &#34;extension&#34;: &#34;png&#34;}], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_lidar.py::test_empty_scene&#34;, &#34;duration&#34;: &#34;214 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_lidar.py::test_empty_scene&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;214 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testmeta\&#34;&gt;&lt;div style=\&#34;min-width:340px;max-width:520px;line-height:1.35;\&#34;&gt;&lt;div&gt;&lt;strong&gt;Test Description:&lt;/strong&gt; Scan an empty scene (no geometry objects). Every beam should return an invalid measurement with reason = &amp;#x27;no_hit&amp;#x27;. No crashes, no valid returns.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Test Goal:&lt;/strong&gt; Confirm the scanner handles the degenerate case of an empty scene gracefully and produces the expected diagnostic output for every beam.&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Passing Criteria:&lt;/strong&gt; num_valid == 0. Every beam has valid == False and reason == &amp;#x27;no_hit&amp;#x27;. Total beam count matches scan_azimuth_samples * len(scan_elevation_angles).&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-plot\&#34;&gt;&lt;a href=\&#34;assets\\tests_test_lidar.py__test_empty_scene_0_0.png\&#34; target=\&#34;_blank\&#34; rel=\&#34;noopener noreferrer\&#34;&gt;&lt;img src=\&#34;assets\\tests_test_lidar.py__test_empty_scene_0_0.png\&#34; alt=\&#34;plot\&#34; style=\&#34;max-width:320px;height:auto;display:block;margin:4px 0;cursor:zoom-in;\&#34; /&gt;&lt;/a&gt;&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}]}, &#34;renderCollapsed&#34;: [&#34;passed&#34;], &#34;initialSort&#34;: &#34;result&#34;, &#34;title&#34;: &#34;report_lidar.html&#34;}"></div>
    <script>
      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const { getCollapsedCategory, setCollapsedIds } = require('./storage.js')

class DataManager {
    setManager(data) {
        const collapsedCategories = [...getCollapsedCategory(data.renderCollapsed)]
        const collapsedIds = []
        const tests = Object.values(data.tests).flat().map((test, index) => {
            const collapsed = collapsedCategories.includes(test.result.toLowerCase())
            const id = `test_${index}`
            if (collapsed) {
                collapsedIds.push(id)
            }
            return {
                ...test,
                id,
                collapsed,
            }
        })
        const dataBlob = { ...data, tests }
        this.data = { ...dataBlob }
        this.renderData = { ...dataBlob }
        setCollapsedIds(collapsedIds)
    }

    get allData() {
        return { ...this.data }
    }

    resetRender() {
        this.renderData = { ...this.data }
    }

    setRender(data) {
        this.renderData.tests = [...data]
    }

    toggleCollapsedItem(id) {
        this.renderData.tests = this.renderData.tests.map((test) =>
            test.id === id ? { ...test, collapsed: !test.collapsed } : test,
        )
    }

    set allCollapsed(collapsed) {
        this.renderData = { ...this.renderData, tests: [...this.renderData.tests.map((test) => (
            { ...test, collapsed }
        ))] }
    }

    get testSubset() {
        return [...this.renderData.tests]
    }

    get environment() {
        return this.renderData.environment
    }

    get initialSort() {
        return this.data.initialSort
    }
}

module.exports = {
    manager: new DataManager(),
}

},{"./storage.js":8}],2:[function(require,module,exports){
const mediaViewer = require('./mediaviewer.js')
const templateEnvRow = document.getElementById('template_environment_row')
const templateResult = document.getElementById('template_results-table__tbody')

function htmlToElements(html) {
    const temp = document.createElement('template')
    temp.innerHTML = html
    return temp.content.childNodes
}

const find = (selector, elem) => {
    if (!elem) {
        elem = document
    }
    return elem.querySelector(selector)
}

const findAll = (selector, elem) => {
    if (!elem) {
        elem = document
    }
    return [...elem.querySelectorAll(selector)]
}

const dom = {
    getStaticRow: (key, value) => {
        const envRow = templateEnvRow.content.cloneNode(true)
        const isObj = typeof value === 'object' && value !== null
        const values = isObj ? Object.keys(value).map((k) => `${k}: ${value[k]}`) : null

        const valuesElement = htmlToElements(
            values ? `<ul>${values.map((val) => `<li>${val}</li>`).join('')}<ul>` : `<div>${value}</div>`)[0]
        const td = findAll('td', envRow)
        td[0].textContent = key
        td[1].appendChild(valuesElement)

        return envRow
    },
    getResultTBody: ({ testId, id, log, extras, resultsTableRow, tableHtml, result, collapsed }) => {
        const resultBody = templateResult.content.cloneNode(true)
        resultBody.querySelector('tbody').classList.add(result.toLowerCase())
        resultBody.querySelector('tbody').id = testId
        resultBody.querySelector('.collapsible').dataset.id = id

        resultsTableRow.forEach((html) => {
            const t = document.createElement('template')
            t.innerHTML = html
            resultBody.querySelector('.collapsible').appendChild(t.content)
        })

        if (log) {
            // Wrap lines starting with "E" with span.error to color those lines red
            const wrappedLog = log.replace(/^E.*$/gm, (match) => `<span class="error">${match}</span>`)
            resultBody.querySelector('.log').innerHTML = wrappedLog
        } else {
            resultBody.querySelector('.log').remove()
        }

        if (collapsed) {
            resultBody.querySelector('.collapsible > .col-result')?.classList.add('collapsed')
            resultBody.querySelector('.extras-row').classList.add('hidden')
        } else {
            resultBody.querySelector('.collapsible > .col-result')?.classList.remove('collapsed')
        }

        const media = []
        extras?.forEach(({ name, format_type, content }) => {
            if (['image', 'video'].includes(format_type)) {
                media.push({ path: content, name, format_type })
            }

            if (format_type === 'html') {
                resultBody.querySelector('.extraHTML').insertAdjacentHTML('beforeend', `<div>${content}</div>`)
            }
        })
        mediaViewer.setup(resultBody, media)

        // Add custom html from the pytest_html_results_table_html hook
        tableHtml?.forEach((item) => {
            resultBody.querySelector('td[class="extra"]').insertAdjacentHTML('beforeend', item)
        })

        return resultBody
    },
}

module.exports = {
    dom,
    htmlToElements,
    find,
    findAll,
}

},{"./mediaviewer.js":6}],3:[function(require,module,exports){
const { manager } = require('./datamanager.js')
const { doSort } = require('./sort.js')
const storageModule = require('./storage.js')

const getFilteredSubSet = (filter) =>
    manager.allData.tests.filter(({ result }) => filter.includes(result.toLowerCase()))

const doInitFilter = () => {
    const currentFilter = storageModule.getVisible()
    const filteredSubset = getFilteredSubSet(currentFilter)
    manager.setRender(filteredSubset)
}

const doFilter = (type, show) => {
    if (show) {
        storageModule.showCategory(type)
    } else {
        storageModule.hideCategory(type)
    }

    const currentFilter = storageModule.getVisible()
    const filteredSubset = getFilteredSubSet(currentFilter)
    manager.setRender(filteredSubset)

    const sortColumn = storageModule.getSort()
    doSort(sortColumn, true)
}

module.exports = {
    doFilter,
    doInitFilter,
}

},{"./datamanager.js":1,"./sort.js":7,"./storage.js":8}],4:[function(require,module,exports){
const { redraw, bindEvents, renderStatic } = require('./main.js')
const { doInitFilter } = require('./filter.js')
const { doInitSort } = require('./sort.js')
const { manager } = require('./datamanager.js')
const data = JSON.parse(document.getElementById('data-container').dataset.jsonblob)

function init() {
    manager.setManager(data)
    doInitFilter()
    doInitSort()
    renderStatic()
    redraw()
    bindEvents()
}

init()

},{"./datamanager.js":1,"./filter.js":3,"./main.js":5,"./sort.js":7}],5:[function(require,module,exports){
const { dom, find, findAll } = require('./dom.js')
const { manager } = require('./datamanager.js')
const { doSort } = require('./sort.js')
const { doFilter } = require('./filter.js')
const {
    getVisible,
    getCollapsedIds,
    setCollapsedIds,
    getSort,
    getSortDirection,
    possibleFilters,
} = require('./storage.js')

const removeChildren = (node) => {
    while (node.firstChild) {
        node.removeChild(node.firstChild)
    }
}

const renderStatic = () => {
    const renderEnvironmentTable = () => {
        const environment = manager.environment
        const rows = Object.keys(environment).map((key) => dom.getStaticRow(key, environment[key]))
        const table = document.getElementById('environment')
        removeChildren(table)
        rows.forEach((row) => table.appendChild(row))
    }
    renderEnvironmentTable()
}

const addItemToggleListener = (elem) => {
    elem.addEventListener('click', ({ target }) => {
        const id = target.parentElement.dataset.id
        manager.toggleCollapsedItem(id)

        const collapsedIds = getCollapsedIds()
        if (collapsedIds.includes(id)) {
            const updated = collapsedIds.filter((item) => item !== id)
            setCollapsedIds(updated)
        } else {
            collapsedIds.push(id)
            setCollapsedIds(collapsedIds)
        }
        redraw()
    })
}

const renderContent = (tests) => {
    const sortAttr = getSort(manager.initialSort)
    const sortAsc = JSON.parse(getSortDirection())
    const rows = tests.map(dom.getResultTBody)
    const table = document.getElementById('results-table')
    const tableHeader = document.getElementById('results-table-head')

    const newTable = document.createElement('table')
    newTable.id = 'results-table'

    // remove all sorting classes and set the relevant
    findAll('.sortable', tableHeader).forEach((elem) => elem.classList.remove('asc', 'desc'))
    tableHeader.querySelector(`.sortable[data-column-type="${sortAttr}"]`)?.classList.add(sortAsc ? 'desc' : 'asc')
    newTable.appendChild(tableHeader)

    if (!rows.length) {
        const emptyTable = document.getElementById('template_results-table__body--empty').content.cloneNode(true)
        newTable.appendChild(emptyTable)
    } else {
        rows.forEach((row) => {
            if (!!row) {
                findAll('.collapsible td:not(.col-links', row).forEach(addItemToggleListener)
                find('.logexpander', row).addEventListener('click',
                    (evt) => evt.target.parentNode.classList.toggle('expanded'),
                )
                newTable.appendChild(row)
            }
        })
    }

    table.replaceWith(newTable)
}

const renderDerived = () => {
    const currentFilter = getVisible()
    possibleFilters.forEach((result) => {
        const input = document.querySelector(`input[data-test-result="${result}"]`)
        input.checked = currentFilter.includes(result)
    })
}

const bindEvents = () => {
    const filterColumn = (evt) => {
        const { target: element } = evt
        const { testResult } = element.dataset

        doFilter(testResult, element.checked)
        const collapsedIds = getCollapsedIds()
        const updated = manager.renderData.tests.map((test) => {
            return {
                ...test,
                collapsed: collapsedIds.includes(test.id),
            }
        })
        manager.setRender(updated)
        redraw()
    }

    const header = document.getElementById('environment-header')
    header.addEventListener('click', () => {
        const table = document.getElementById('environment')
        table.classList.toggle('hidden')
        header.classList.toggle('collapsed')
    })

    findAll('input[name="filter_checkbox"]').forEach((elem) => {
        elem.addEventListener('click', filterColumn)
    })

    findAll('.sortable').forEach((elem) => {
        elem.addEventListener('click', (evt) => {
            const { target: element } = evt
            const { columnType } = element.dataset
            doSort(columnType)
            redraw()
        })
    })

    document.getElementById('show_all_details').addEventListener('click', () => {
        manager.allCollapsed = false
        setCollapsedIds([])
        redraw()
    })
    document.getElementById('hide_all_details').addEventListener('click', () => {
        manager.allCollapsed = true
        const allIds = manager.renderData.tests.map((test) => test.id)
        setCollapsedIds(allIds)
        redraw()
    })
}

const redraw = () => {
    const { testSubset } = manager

    renderContent(testSubset)
    renderDerived()
}

module.exports = {
    redraw,
    bindEvents,
    renderStatic,
}

},{"./datamanager.js":1,"./dom.js":2,"./filter.js":3,"./sort.js":7,"./storage.js":8}],6:[function(require,module,exports){
class MediaViewer {
    constructor(assets) {
        this.assets = assets
        this.index = 0
    }

    nextActive() {
        this.index = this.index === this.assets.length - 1 ? 0 : this.index + 1
        return [this.activeFile, this.index]
    }

    prevActive() {
        this.index = this.index === 0 ? this.assets.length - 1 : this.index -1
        return [this.activeFile, this.index]
    }

    get currentIndex() {
        return this.index
    }

    get activeFile() {
        return this.assets[this.index]
    }
}


const setup = (resultBody, assets) => {
    if (!assets.length) {
        resultBody.querySelector('.media').classList.add('hidden')
        return
    }

    const mediaViewer = new MediaViewer(assets)
    const container = resultBody.querySelector('.media-container')
    const leftArrow = resultBody.querySelector('.media-container__nav--left')
    const rightArrow = resultBody.querySelector('.media-container__nav--right')
    const mediaName = resultBody.querySelector('.media__name')
    const counter = resultBody.querySelector('.media__counter')
    const imageEl = resultBody.querySelector('img')
    const sourceEl = resultBody.querySelector('source')
    const videoEl = resultBody.querySelector('video')

    const setImg = (media, index) => {
        if (media?.format_type === 'image') {
            imageEl.src = media.path

            imageEl.classList.remove('hidden')
            videoEl.classList.add('hidden')
        } else if (media?.format_type === 'video') {
            sourceEl.src = media.path

            videoEl.classList.remove('hidden')
            imageEl.classList.add('hidden')
        }

        mediaName.innerText = media?.name
        counter.innerText = `${index + 1} / ${assets.length}`
    }
    setImg(mediaViewer.activeFile, mediaViewer.currentIndex)

    const moveLeft = () => {
        const [media, index] = mediaViewer.prevActive()
        setImg(media, index)
    }
    const doRight = () => {
        const [media, index] = mediaViewer.nextActive()
        setImg(media, index)
    }
    const openImg = () => {
        window.open(mediaViewer.activeFile.path, '_blank')
    }
    if (assets.length === 1) {
        container.classList.add('media-container--fullscreen')
    } else {
        leftArrow.addEventListener('click', moveLeft)
        rightArrow.addEventListener('click', doRight)
    }
    imageEl.addEventListener('click', openImg)
}

module.exports = {
    setup,
}

},{}],7:[function(require,module,exports){
const { manager } = require('./datamanager.js')
const storageModule = require('./storage.js')

const genericSort = (list, key, ascending, customOrder) => {
    let sorted
    if (customOrder) {
        sorted = list.sort((a, b) => {
            const aValue = a.result.toLowerCase()
            const bValue = b.result.toLowerCase()

            const aIndex = customOrder.findIndex((item) => item.toLowerCase() === aValue)
            const bIndex = customOrder.findIndex((item) => item.toLowerCase() === bValue)

            // Compare the indices to determine the sort order
            return aIndex - bIndex
        })
    } else {
        sorted = list.sort((a, b) => a[key] === b[key] ? 0 : a[key] > b[key] ? 1 : -1)
    }

    if (ascending) {
        sorted.reverse()
    }
    return sorted
}

const durationSort = (list, ascending) => {
    const parseDuration = (duration) => {
        if (duration.includes(':')) {
            // If it's in the format "HH:mm:ss"
            const [hours, minutes, seconds] = duration.split(':').map(Number)
            return (hours * 3600 + minutes * 60 + seconds) * 1000
        } else {
            // If it's in the format "nnn ms"
            return parseInt(duration)
        }
    }
    const sorted = list.sort((a, b) => parseDuration(a['duration']) - parseDuration(b['duration']))
    if (ascending) {
        sorted.reverse()
    }
    return sorted
}

const doInitSort = () => {
    const type = storageModule.getSort(manager.initialSort)
    const ascending = storageModule.getSortDirection()
    const list = manager.testSubset
    const initialOrder = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed', 'Skipped', 'Passed']

    storageModule.setSort(type)
    storageModule.setSortDirection(ascending)

    if (type?.toLowerCase() === 'original') {
        manager.setRender(list)
    } else {
        let sortedList
        switch (type) {
        case 'duration':
            sortedList = durationSort(list, ascending)
            break
        case 'result':
            sortedList = genericSort(list, type, ascending, initialOrder)
            break
        default:
            sortedList = genericSort(list, type, ascending)
            break
        }
        manager.setRender(sortedList)
    }
}

const doSort = (type, skipDirection) => {
    const newSortType = storageModule.getSort(manager.initialSort) !== type
    const currentAsc = storageModule.getSortDirection()
    let ascending
    if (skipDirection) {
        ascending = currentAsc
    } else {
        ascending = newSortType ? false : !currentAsc
    }
    storageModule.setSort(type)
    storageModule.setSortDirection(ascending)

    const list = manager.testSubset
    const sortedList = type === 'duration' ? durationSort(list, ascending) : genericSort(list, type, ascending)
    manager.setRender(sortedList)
}

module.exports = {
    doInitSort,
    doSort,
}

},{"./datamanager.js":1,"./storage.js":8}],8:[function(require,module,exports){
const possibleFilters = [
    'passed',
    'skipped',
    'failed',
    'error',
    'xfailed',
    'xpassed',
    'rerun',
]

const getVisible = () => {
    const url = new URL(window.location.href)
    const settings = new URLSearchParams(url.search).get('visible')
    const lower = (item) => {
        const lowerItem = item.toLowerCase()
        if (possibleFilters.includes(lowerItem)) {
            return lowerItem
        }
        return null
    }
    return settings === null ?
        possibleFilters :
        [...new Set(settings?.split(',').map(lower).filter((item) => item))]
}

const hideCategory = (categoryToHide) => {
    const url = new URL(window.location.href)
    const visibleParams = new URLSearchParams(url.search).get('visible')
    const currentVisible = visibleParams ? visibleParams.split(',') : [...possibleFilters]
    const settings = [...new Set(currentVisible)].filter((f) => f !== categoryToHide).join(',')

    url.searchParams.set('visible', settings)
    window.history.pushState({}, null, unescape(url.href))
}

const showCategory = (categoryToShow) => {
    if (typeof window === 'undefined') {
        return
    }
    const url = new URL(window.location.href)
    const currentVisible = new URLSearchParams(url.search).get('visible')?.split(',').filter(Boolean) ||
        [...possibleFilters]
    const settings = [...new Set([categoryToShow, ...currentVisible])]
    const noFilter = possibleFilters.length === settings.length || !settings.length

    noFilter ? url.searchParams.delete('visible') : url.searchParams.set('visible', settings.join(','))
    window.history.pushState({}, null, unescape(url.href))
}

const getSort = (initialSort) => {
    const url = new URL(window.location.href)
    let sort = new URLSearchParams(url.search).get('sort')
    if (!sort) {
        sort = initialSort || 'result'
    }
    return sort
}

const setSort = (type) => {
    const url = new URL(window.location.href)
    url.searchParams.set('sort', type)
    window.history.pushState({}, null, unescape(url.href))
}

const getCollapsedCategory = (renderCollapsed) => {
    let categories
    if (typeof window !== 'undefined') {
        const url = new URL(window.location.href)
        const collapsedItems = new URLSearchParams(url.search).get('collapsed')
        switch (true) {
        case !renderCollapsed && collapsedItems === null:
            categories = ['passed']
            break
        case collapsedItems?.length === 0 || /^["']{2}$/.test(collapsedItems):
            categories = []
            break
        case /^all$/.test(collapsedItems) || collapsedItems === null && /^all$/.test(renderCollapsed):
            categories = [...possibleFilters]
            break
        default:
            categories = collapsedItems?.split(',').map((item) => item.toLowerCase()) || renderCollapsed
            break
        }
    } else {
        categories = []
    }
    return categories
}

const getSortDirection = () => JSON.parse(sessionStorage.getItem('sortAsc')) || false
const setSortDirection = (ascending) => sessionStorage.setItem('sortAsc', ascending)

const getCollapsedIds = () => JSON.parse(sessionStorage.getItem('collapsedIds')) || []
const setCollapsedIds = (list) => sessionStorage.setItem('collapsedIds', JSON.stringify(list))

module.exports = {
    getVisible,
    hideCategory,
    showCategory,
    getCollapsedIds,
    setCollapsedIds,
    getSort,
    setSort,
    getSortDirection,
    setSortDirection,
    getCollapsedCategory,
    possibleFilters,
}

},{}]},{},[4]);
    </script>
  </footer>
  </body>
</html>